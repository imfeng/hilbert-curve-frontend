<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
  <!-- <script src='//unpkg.com/hilbert-chart'></script> -->
  <script src="../../dist/hilbert-chart.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"
    integrity="sha512-WFN04846sdKMIP5LKNphMaWzU7YpMyCU245etK3g/2ARYbPK9Ub18eG+ljU96qKRCWh+quCY7yefSmlkQw1ANQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>
  <script
    src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"
    type="application/javascript"
  ></script>
  <style>
    body {
      width: 100vw;
      margin: 0;
      text-align: center;
    }

    #content {
      width: 100%;
      display: flex;
    }

    #chart {
      width: 69%;
      display: inline-block;
      flex: 1 2 0;
    }
    #web3 {
      width: 30%;
      flex: 1 1 0;
      /* background: #3a5894; */
    }
  </style>
  <style>
    svg path {
      fill: none;
      stroke: #3a5894;
      stroke-width: 0.3;
      stroke-linecap: square;
    }

    svg path.skeleton {
      stroke: #eee;
      stroke-width: 0.1;
    }

    #val-tooltip {
      display: none;
      position: absolute;
      margin-top: 22px;
      margin-left: -1px;
      padding: 5px;
      border-radius: 3px;
      font: 11px sans-serif;
      color: #eee;
      background: rgba(0, 0, 140, 0.9);
      text-align: center;
      pointer-events: none;
    }
  </style>
  <style>
    .connectBox {
      display: flex;
      flex-direction: row;
      justify-content: right;
      align-items: center;
      margin: 1.5rem;
    }
    .connectBtn {
      background-color: gray;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 15px;
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
    }
    .connectBtn:hover {
      background-color: black;
      color: white;
    }
    .boxGroup {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      margin: 10px;
    }
    .selectBox {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin: 10px;
      font-size: 1.5rem;
      font-weight: 600;
    }
    .selectBox input {
      margin: 0 5px;
    }
    .sizeItemSelector {
      width: 30px;
      height: 30px;
    }
    .mintBtn {
      background-color: gray;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 15px;
      font-size: 1.2rem;
      cursor: pointer;
    }
    .mintBtn:hover {
      background-color: black;
      color: white;
    }
  </style>
</head>
<body>
  <div id="content">
    <div id="chart"></div>
    <div id="chart-container">
      <button onclick="showLine()">toggle Lines</button>
    </div>
    <div id="web3">
      <div>
        <div class="connectBox">
          <button class="connectBtn">connect</button>
        </div>
        <div class="boxGroup">
          <div class="selectBox">
            <input
              class="sizeItemSelector"
              type="radio"
              name="sizeItemSelector"
              value="0"
              checked
            />
            <label for="smallLand">1x1</label>
          </div>
          <div class="selectBox">
            <input
              class="sizeItemSelector"
              type="radio"
              name="sizeItemSelector"
              value="1"
            />
            <label for="mediumLand">2x2</label>
          </div>
          <div class="selectBox">
            <input
              class="sizeItemSelector"
              type="radio"
              name="sizeItemSelector"
              value="2"
            />
            <label for="largeLand">4x4</label>
          </div>
          <div class="selectBox">
            <input
              class="sizeItemSelector"
              type="radio"
              name="sizeItemSelector"
              value="3"
            />
            <label for="xLargeLand">8x8</label>
          </div>
        </div>
        <div>
          <button class="mintBtn" id="mint" onclick="mintBuilding()">
            Mint
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Hilbert Spec
    const canvaseWidthRate = 0.63;
    const hilbertOrder = 5;
    const hilbertLength = Math.pow(4, hilbertOrder);

    // Gen random data
    const N_CAT = Math.pow(Math.pow(2, hilbertOrder), 2);
    const MAX_VAL = 100;
    const data = [...Array(N_CAT)].map((_, i) => ({
      name: `${i}`,
      val: 1,
    }));

    const dataSum = data
      .map(({ val }) => val)
      .reduce((acc, val) => acc + val, 0);
    const getHilbertVal = (val) => Math.round((val / dataSum) * hilbertLength);

    let carry = 0;
    const hilbertData = data.map(({ val, ...rest }) => {
      const d = {
        start: carry,
        length: val, // getHilbertVal(val),
        val,
        ...rest,
        img: "/11.jpeg",
        hi: "123",
      };
      carry += d.length;
      return d;
    });
    var state = {
      currentNode: null,
      size: 0,
    };

    const chartElement = document.getElementById("chart");

    const initHilbertChart = HilbertChart()
      .margin(30)
      .hilbertOrder(hilbertOrder)
      .data(hilbertData)
      .rangePadding(0.1)
      // .valFormatter(n => Math.round(n / hilbertLength * dataSum))
      .showValTooltip(true)
      .onRangeClick(onClickNode);
    // .onRangeHover((d) => {
    //   console.log('hover', d);
    // })
    // .rangeTooltipContent(({ name, val }) => `<b>${name}</b>: ${val} (${Math.round(val / dataSum * 100)}%)`);

    const target = initHilbertChart(chartElement);
    console.log({ target });

    const resizeContent = _.debounce((ev) => {
      const width = window.innerWidth * canvaseWidthRate;
      const height = window.screen.height;
      const size = Math.min(width, height);
      target.width(size);
      console.log(size);
    }, 500);
    listenScreenSizeChange();
    function listenScreenSizeChange() {
      resizeContent();
      window.addEventListener("resize", resizeContent);
    }

    function showLine() {
      target.toggleLinepaths();
      resizeContent();
    }

    function getLeadNodes(hIndex, n) {
      const MAX_UINT256 = BigInt(
        "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
      );
      const N = n + 1;
      let leadNodes = [];
      let mask = MAX_UINT256;
      leadNodes.push(hIndex.toString());
      for (let i = 1; i < N; i++) {
        // Shift 2 bits to get the next lead node
        mask = mask << 2n;
        const leadNode = BigInt(hIndex) & mask;
        leadNodes.push(leadNode.toString());
        // The last lead node is 0
        if (leadNode === 0n) break;
      }
      return leadNodes.map((v) => v.toString());
    }

    function listenSizeRadioOnchange() {
      $("input[type=radio][name=sizeItemSelector]").change(function () {
        state.size = getCurrentSize();
        console.log("onSizeRadioOnchange");
        if (state.currentNode) {
          onClickNode(state.currentNode);
        }
      });
    }
    listenSizeRadioOnchange();

    function onClickNode(d) {
      console.log("click", d);
      const size = getCurrentSize();
      console.log({ size });
      const sizeLength = Math.pow(Math.pow(2, size), 2);
      const leadNodes = getLeadNodes(d.start, hilbertOrder);
      const leadNode = parseInt(leadNodes[size]);
      const leadD = hilbertData[leadNode];
      for (let index = leadD.start; index < leadD.start + sizeLength; index++) {
        const dd = hilbertData[index];
        if (dd.disabled) {
          state.currentNode = null;
          target.resetActiveNodes();
          alert("This land is not available");
          return;
        }
      }
      state.currentNode = leadD;
      const nodes = new Array(sizeLength).fill(leadNode).map((v, i) => v + i);
      const resultMap = nodes.reduce((acc, v) => {
        acc[v] = true;
        return acc;
      }, {});
      console.log({
        currentNode: state.currentNode,
        size,
        sizeLength,
        leadNodes,
        nodes,
        resultMap,
      });
      target.activeMap(resultMap);
    }

    function getCurrentSize() {
      return parseInt(
        $("input[type=radio][name=sizeItemSelector]:checked").val()
      );
    }
  </script>

  <script>
    // connect
    const unitPrice = ethers.utils.parseEther("0.001");
    const connectBtn = document.querySelector(".connectBtn");
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    var web3State = {
      addr: null,
      contract: null,
    };

    $(".connectBtn").click(async function (event) {
      await provider.send("eth_requestAccounts", []);
      await delay(1000);
      const signer = provider.getSigner();
      const addr = await signer.getAddress();
      web3State.addr = addr;

      $(".connectBtn").text(addr.slice(0, 6) + "..." + addr.slice(-4));

      const abi = await getABI();
      web3State.contract = new ethers.Contract(
        "0x112559F00408984CE1c8a7B6D844A61662182FA6",
        abi,
        signer
      );
    });

    async function mintBuilding() {
      const { addr, contract } = web3State;
      const hIndex = state.currentNode.start;
      const quadrant = 1;
      const size = getCurrentSize();
      const price = unitPrice.mul(Math.pow(2, size));
      const tx = await contract.mintBuilding(hIndex, quadrant, size, {
        value: price,
        from: addr,
      });
      console.log({ tx });
    }

    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function getABI() {
      const abi = await $.getJSON("./abi/abi.json");
      return abi;
    }
  </script>
</body>
